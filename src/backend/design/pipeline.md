# 处理管线

对于数据的入库，设计了一个处理管线来完成这一步

## 预处理

该步骤通常由接入点处理。

我们假设我们收取到了如下的消息

```json
{
  "Alice": "Hi",
  "Bob": "Hey!",
  "Alice": {
    "Alice": "Good morning!",
    "Bob": "Good night!"
  }
}
```

### 扁平化

在这一步，我们需要将所有的信息全部扁平化。

从上面的例子中我们将会得到如下的扁平化结果：

```json
[
  { "Alice": "Hi" },
  { "Bob": "Hey!" },
  { "Alice": "Good morning!" },
  { "Bob": "Good night!" }
]
```

然后我们将这个扁平化的结果发送给后端，后端将会对这些数据进行处理，返回如下结果给你

```json
[
  "e386a9d2-9ab0-41ff-9f54-9f0f1dfa7d01",
  "75c3f52b-2eed-43e2-bbc7-04c133b36423",
  "a8f8c6fb-f548-435d-a6d7-0b2acc8e33c2",
  "df65d801-fca5-44fa-871d-bf14f45d8510"
]
```

> 请注意，这里只是举例用于展示逻辑，具体的格式需要根据后端和接入点的定义做出变动

这些结果的顺序和传入的顺序保持一致，那么由此可以得到双向映射：

- 可以从消息记录得到 UUID
- 可以从 UUID 得到消息记录

> 在 Java 中叫作 `BiMap<String", String>`

### 构造切片

在得到了消息和 UUID 的双向映射后，我们可以开始构建切片了

> 如果忘了切片和消息的关系，请复习一下 [约定](../../common.md)

在以上的例子中我们发现，接入点接收到的信息有两层，那么我们需要构建两个切片

切片 1:

```json
{
  "Alice": "Good morning!",
  "Bob": "Good night!"
}
```

切片 2：

```json
{
  "Alice": "Hi",
  "Bob": "Hey!",
  "Alice": {}
}
```

请注意，这里产生了一种特殊情况：切片2的第三条消息是一个**嵌套消息**，我们将其作为一个切片单独提取出来成为切片 1。

接下来我们将构建出来的映射替换回去，于是我们得到了

切片 1：

```json
["a8f8c6fb-f548-435d-a6d7-0b2acc8e33c2", "df65d801-fca5-44fa-871d-bf14f45d8510"]
```

由于切片 2 包含一层嵌套消息，因此我们需要先将其发送给服务端获取到这个嵌套消息的 UUID，我们假设得到了 `b51c77c7-f0c3-4202-8103-c770c733d589`，则我们接下来的切片 2 就成为了

切片 2:

```json
[
  "e386a9d2-9ab0-41ff-9f54-9f0f1dfa7d01",
  "75c3f52b-2eed-43e2-bbc7-04c133b36423",
  "b51c77c7-f0c3-4202-8103-c770c733d589"
]
```
